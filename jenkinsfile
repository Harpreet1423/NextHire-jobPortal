pipeline {
    agent any

    environment {
        AWS_DEFAULT_REGION = 'us-east-1'
        ECR_REPO = '345376996795.dkr.ecr.us-east-1.amazonaws.com/job-portal'
        IMAGE_TAG = "build-${BUILD_NUMBER}"
        SONAR_HOST_URL = 'http://localhost:9000'
        SONAR_PROJECT_KEY = 'NextHire-jobPortal'
        SONAR_TOKEN = credentials('sonar-auth-token') // Jenkins credential ID for SonarQube
        SNYK_TOKEN = credentials('SNYK_TOKEN')    // ✅ Jenkins credential ID for Snyk
    }

    stages {

        stage('Checkout Code') {
            steps {
                git branch: 'main', url: 'https://github.com/Harpreet1423/NextHire-jobPortal.git'
            }
        }
stage('SonarQube Analysis') {
    steps {
        withSonarQubeEnv('sonarqube') {
            script {
                def scannerHome = tool name: 'SonarScannerDefault', type: 'hudson.plugins.sonar.SonarRunnerInstallation'
                bat """
                    "${scannerHome}\\bin\\sonar-scanner.bat" ^
                    -Dsonar.projectKey=%SONAR_PROJECT_KEY% ^
                    -Dsonar.sources=. ^
                    -Dsonar.host.url=%SONAR_HOST_URL% ^
                    -Dsonar.login=%SONAR_TOKEN%
                """
            }
        }
    }
}

        
       stage('Snyk Security Scan') {
    steps {
        script {
            // Install Snyk CLI
            bat 'npm install -g snyk'

            // No interactive auth. Snyk picks token from SNYK_TOKEN env var.
            // Run tests in non-interactive CI mode:
            bat 'snyk test --all-projects --ci'

            // Optional: send a snapshot to Snyk dashboard
            bat 'snyk monitor --all-projects'
        }
    }
}

    
        stage('Terraform - Provision Infra') {
        steps {
    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding',
      accessKeyVariable: 'AWS_ACCESS_KEY_ID',
      secretKeyVariable: 'AWS_SECRET_ACCESS_KEY',
      credentialsId: 'aws-creds']]) {
      dir('terraform') {
        // Init terraform
        bat 'terraform init -no-color'

        // Use PowerShell to check for existing ECR repo and import if present,
        // but don't fail if repo is not present.
        powershell """
        \$ErrorActionPreference = 'Stop'

        # Export AWS creds to env for aws CLI used inside powershell
        \$env:AWS_ACCESS_KEY_ID = '${env.AWS_ACCESS_KEY_ID}'
        \$env:AWS_SECRET_ACCESS_KEY = '${env.AWS_SECRET_ACCESS_KEY}'
        \$env:AWS_DEFAULT_REGION = '${env.AWS_DEFAULT_REGION}'

        Write-Host "Checking if ECR repository 'job-portal' exists..."
        try {
          aws ecr describe-repositories --repository-names job-portal --region \$env:AWS_DEFAULT_REGION > \$null 2>&1
          \$repoExists = \$LASTEXITCODE -eq 0
        } catch {
          \$repoExists = \$false
        }

        if (\$repoExists) {
          Write-Host "ECR repo exists — attempting terraform import (safe if already imported)."
          # Only try to import when the resource is not already in state.
          \$inState = (terraform state list -no-color 2>\$null) -contains 'aws_ecr_repository.job_portal'
          if (-not \$inState) {
            try {
              terraform import -no-color aws_ecr_repository.job_portal job-portal
              Write-Host "Import completed."
            } catch {
              Write-Warning "terraform import failed: \$($_.Exception.Message) - continuing to plan"
            }
          } else {
            Write-Host "Resource already in terraform state - skipping import"
          }
        } else {
          Write-Host "ECR repo does not exist. Terraform will create it."
        }

        Write-Host "Running terraform plan..."
        terraform plan -input=false -no-color -out=tfplan

        Write-Host "Applying terraform..."
        terraform apply -input=false -no-color -auto-approve tfplan
        """

        // Optional: capture outputs
        bat 'terraform output -no-color || echo "No outputs or terraform failed to output"'
      }
    }
  }
}


        stage('Docker Build') {
            steps {
                bat "docker build -t app:%IMAGE_TAG% ."
            }
        }

        stage('Trivy Scan') {
            steps {
                bat "trivy image app:%IMAGE_TAG%"
            }
        }

        stage('Push to ECR') {
            steps {
                bat """
                    aws ecr get-login-password --region %AWS_DEFAULT_REGION% | docker login --username AWS --password-stdin %ECR_REPO%
                    docker tag app:%IMAGE_TAG% %ECR_REPO%:latest
                    docker push %ECR_REPO%:latest
                """
            }
        }

        stage('Deploy to Staging ECS') {
            steps {
                bat 'aws ecs update-service --cluster staging-cluster --service staging-service --force-new-deployment'
            }
        }

        stage('OWASP ZAP DAST') {
            steps {
                bat 'zap-cli start && zap-cli open-url http://staging-url && zap-cli quick-scan http://staging-url'
            }
        }

        stage('Deploy to Production ECS') {
            steps {
                bat 'aws ecs update-service --cluster prod-cluster --service prod-service --force-new-deployment'
            }
        }

        stage('Fetch Secrets') {
            steps {
                bat 'aws secretsmanager get-secret-value --secret-id my-secret-id'
            }
        }
    }

    post {
        always {
            echo 'Pipeline finished.'
            cleanWs()
        }
        failure {
            echo 'Pipeline failed! Investigate logs and try again.'
        }
    }
}
