pipeline {
    agent any

    environment {
        AWS_DEFAULT_REGION = 'us-east-1'
        ECR_REPO = '345376996795.dkr.ecr.us-east-1.amazonaws.com/job-portal'
        IMAGE_TAG = "build-${BUILD_NUMBER}"
        ECR_IMAGE = "${ECR_REPO}:${IMAGE_TAG}"
        SONAR_HOST_URL = 'http://localhost:9000'
        SONAR_PROJECT_KEY = 'NextHire-jobPortal'
        TRIVY_MODE = 'blocking'
         STAGING_CLUSTER = 'job-portal-staging-cluster'
        STAGING_SERVICE = 'job-portal-staging-service'
        PRODUCTION_CLUSTER = 'job-portal-cluster'
        PRODUCTION_SERVICE = 'job-portal-service'
        
    }

    stages {

        stage('Checkout Code') {
            steps {
                git branch: 'main', url: 'https://github.com/Harpreet1423/NextHire-jobPortal.git'
            }
        }

        // stage('SonarQube Analysis') {
        //     steps {
        //         withSonarQubeEnv('sonarqube') {
        //             withCredentials([string(credentialsId: 'sonar-auth-token', variable: 'SONAR_TOKEN')]) {
        //                 script {
        //                     def scannerHome = tool name: 'SonarScannerDefault', type: 'hudson.plugins.sonar.SonarRunnerInstallation'
        //                     // Windows bat: use %SONAR_TOKEN%
        //                     bat """
        //                         "${scannerHome}\\bin\\sonar-scanner.bat" ^
        //                         -Dsonar.projectKey=${env.SONAR_PROJECT_KEY} ^
        //                         -Dsonar.sources=. ^
        //                         -Dsonar.host.url=${env.SONAR_HOST_URL} ^
        //                         -Dsonar.token=%SONAR_TOKEN%
        //                     """
        //                 }
        //             }
        //         }
        //     }
        // }

        // stage('Snyk Security Scan') {
        //     steps {
        //         withCredentials([string(credentialsId: 'SNYK_TOKEN', variable: 'SNYK_TOKEN')]) {
        //             bat 'npm install -g snyk'
        //             // pass token via env var configured by withCredentials
        //             bat 'set SNYK_TOKEN=%SNYK_TOKEN% && snyk test --all-projects --ci'
        //             bat 'set SNYK_TOKEN=%SNYK_TOKEN% && snyk monitor --all-projects'
        //         }
        //     }
        // }

        // stage('Terraform - Provision Infra') {
        //     steps {
        //         withCredentials([
        //             [$class: 'AmazonWebServicesCredentialsBinding',
        //              accessKeyVariable: 'AWS_ACCESS_KEY_ID',
        //              secretKeyVariable: 'AWS_SECRET_ACCESS_KEY',
        //              credentialsId: 'aws-creds']
        //         ]) {
        //             dir('terraform') {
        //                 bat 'terraform init -upgrade'
        //                 bat 'terraform plan -out=tfplan'
        //                 bat 'terraform apply -auto-approve tfplan'
        //             }
        //         }
        //     }
        // }

        stage('Terraform - Provision Infra') {
    steps {
        withCredentials([
            [$class: 'AmazonWebServicesCredentialsBinding',
             accessKeyVariable: 'AWS_ACCESS_KEY_ID',
             secretKeyVariable: 'AWS_SECRET_ACCESS_KEY',
             credentialsId: 'aws-creds']
        ]) {
            dir('terraform') {
                bat 'terraform init -upgrade'
                
                // Import existing IAM role if it exists
                bat '''
                    terraform import aws_iam_role.ecs_task_execution_role job-portal-ecs-execution-role 2>nul || echo "Role import skipped - may already be in state"
                '''
                
                bat 'terraform plan -out=tfplan'
                bat 'terraform apply -auto-approve tfplan'
            }
        }
    }
}

        stage('Docker Build') {
            steps {
                script {
                  // Use returnStatus to catch failures and fail with a descriptive message
                  def rc = bat(script: "docker build -t app:${IMAGE_TAG} -f Dockerfile .", returnStatus: true)
                  if (rc != 0) {
                    error "Docker build failed with exit code ${rc}"
                  }
                  rc = bat(script: "docker tag app:${IMAGE_TAG} ${ECR_IMAGE}", returnStatus: true)
                  if (rc != 0) {
                    error "Docker tag failed with exit code ${rc}"
                  }
                }
            }
        }
//         stage('Trivy Scan (image)') {
//   environment {
//     // Default to fail only on CRITICAL. To fail on HIGH+CRITICAL set 'HIGH,CRITICAL'
//     TRIVY_FAIL_SEVERITIES = 'CRITICAL'
//   }
//   steps {
//     echo "===== Trivy scan will use image: ${ECR_IMAGE} ====="
//     script {
//       env.TRIVY_REPORT = "trivy-report-${BUILD_NUMBER}.json"
//     }

//     // PowerShell helper script (avoid problematic backslashes for Groovy parsing)
//     writeFile file: 'run-trivy-and-parse.ps1', text: '''
// param(
//   [Parameter(Mandatory=$true)][string]$image,
//   [Parameter(Mandatory=$true)][string]$reportFile,
//   [Parameter(Mandatory=$false)][string]$trivyMode = 'blocking',
//   [Parameter(Mandatory=$false)][string]$failSevList = 'CRITICAL'
// )

// function Run-Trivy {
//     param([string]$img, [string]$outFile)

//     if (Get-Command trivy -ErrorAction SilentlyContinue) {
//         Write-Host "Trivy CLI found locally. Scanning image: $img"
//         trivy image --format json --output $outFile $img
//         return $LASTEXITCODE
//     }

//     Write-Host "Trivy CLI not found locally; attempting to run Trivy via Docker..."
//     if (-not (Get-Command docker -ErrorAction SilentlyContinue)) {
//         Write-Error "Docker not found on agent; cannot run Trivy via container."
//         return 2
//     }

//     $ws = $env:WORKSPACE
//     if (-not $ws) {
//         Write-Error "WORKSPACE environment variable is not set. Aborting."
//         return 3
//     }

//     # Use explicit drive mount formatting to avoid variable parsing issues
//     $workdirMount = "$($ws):/workdir"
//     Write-Host "Running trivy container; workspace mounted: $workdirMount"

//     try {
//         docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -v $workdirMount aquasec/trivy:latest image --format json --output /workdir/$outFile $img
//         return $LASTEXITCODE
//     } catch {
//         Write-Error "Failed to run trivy container: $_"
//         return 4
//     }
// }

// $rc = Run-Trivy -img $image -outFile $reportFile
// if ($rc -ne 0) {
//     Write-Error "Trivy run failed with exit code $rc"
//     exit $rc
// }

// try {
//     $json = Get-Content -Raw $reportFile | ConvertFrom-Json
// } catch {
//     Write-Error "Failed to read/parse $reportFile : $_"
//     exit 5
// }

// # Remove spaces from list and build array (case-insensitive)
// $failSevList = $failSevList.Replace(' ', '')
// $failSevs = @()
// if ($failSevList) {
//     $failSevs = $failSevList.Split(',') | ForEach-Object { $_.ToUpperInvariant() }
// }

// $count = 0
// if ($json -and $json.Results) {
//     foreach ($res in $json.Results) {
//         if ($res.Vulnerabilities) {
//             foreach ($v in $res.Vulnerabilities) {
//                 if ($v.Severity) {
//                     $sev = $v.Severity.ToUpperInvariant()
//                     if ($sev -in $failSevs) { $count++ }
//                 }
//             }
//         }
//     }
// }

// Write-Host "Trivy findings matching failure severities ($($failSevs -join ',')) : $count"

// if ($trivyMode -eq 'blocking' -and $count -gt 0) {
//     Write-Host "Blocking mode enabled and $count findings in configured severities -> failing (exit 1)"
//     exit 1
// }

// Write-Host "No blocking condition met -> success (exit 0)"
// exit 0
// '''

//     // Execute PowerShell script, pass args
//     bat """
//       powershell -NoProfile -ExecutionPolicy Bypass -File run-trivy-and-parse.ps1 -image "${ECR_IMAGE}" -reportFile "${TRIVY_REPORT}" -trivyMode "${TRIVY_MODE}" -failSevList "${TRIVY_FAIL_SEVERITIES}"
//     """

//     // Archive the report so you can download from the Jenkins UI
//     archiveArtifacts artifacts: 'trivy-report-*.json', fingerprint: true, allowEmptyArchive: false
//   }
// }




        stage('Push to ECR') {
            steps {
                withCredentials([
                    [$class: 'AmazonWebServicesCredentialsBinding',
                     accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                     secretKeyVariable: 'AWS_SECRET_ACCESS_KEY',
                     credentialsId: 'aws-creds']
                ]) {
                    script {
                        // Use returnStatus to catch login/push errors and fail with clear message
                        def cmd = """
                            aws ecr get-login-password --region ${env.AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${env.ECR_REPO}
                            docker tag app:${IMAGE_TAG} ${ECR_REPO}:${IMAGE_TAG}
                            docker push ${ECR_REPO}:${IMAGE_TAG}
                            rem also push latest (optional)
                            docker tag app:${IMAGE_TAG} ${ECR_REPO}:latest
                            docker push ${ECR_REPO}:latest
                        """
                        def rc = bat(script: cmd, returnStatus: true)
                        if (rc != 0) {
                            error "Push to ECR failed with exit code ${rc}"
                        } else {
                            echo "Push to ECR succeeded"
                        }
                    }
                }
            }
        }


        stage('Deploy to Staging') {
    steps {
        withCredentials([
            [$class: 'AmazonWebServicesCredentialsBinding',
             accessKeyVariable: 'AWS_ACCESS_KEY_ID',
             secretKeyVariable: 'AWS_SECRET_ACCESS_KEY',
             credentialsId: 'aws-creds']
        ]) {
            script {
                echo "üöÄ Deploying to STAGING environment..."
                echo "Cluster: ${STAGING_CLUSTER}, Service: ${STAGING_SERVICE}"
                
                // Simple force deployment - ECS will pull the latest image with the same tag
                def rc = bat(script: "aws ecs update-service --cluster ${STAGING_CLUSTER} --service ${STAGING_SERVICE} --force-new-deployment --region ${env.AWS_DEFAULT_REGION}", returnStatus: true)
                
                if (rc != 0) {
                    error "Staging deployment failed with exit code ${rc}"
                } else {
                    echo "‚úÖ Staging deployment initiated successfully"
                    
                    // Optional: Wait for deployment
                    echo "Waiting for staging deployment to stabilize..."
                    def waitRc = bat(script: "aws ecs wait services-stable --cluster ${STAGING_CLUSTER} --services ${STAGING_SERVICE} --region ${env.AWS_DEFAULT_REGION}", returnStatus: true)
                    if (waitRc == 0) {
                        echo "‚úÖ Staging deployment completed successfully"
                    } else {
                        echo "‚ö†Ô∏è Staging deployment may still be in progress"
                    }
                }
            }
        }
    }
}

       stage('Deploy to Production ECS') {
    steps {
        withCredentials([
            [$class: 'AmazonWebServicesCredentialsBinding',
             accessKeyVariable: 'AWS_ACCESS_KEY_ID',
             secretKeyVariable: 'AWS_SECRET_ACCESS_KEY',
             credentialsId: 'aws-creds']
        ]) {
            script {
                echo "Deploying to ECS cluster: job-portal-production-cluster, service: job-portal-production-service"
                
                def rc = bat(script: "aws ecs update-service --cluster job-portal-production-cluster --service job-portal-production-service --force-new-deployment --region ${env.AWS_DEFAULT_REGION}", returnStatus: true)
                
                if (rc != 0) {
                    error "ECS update-service failed with exit code ${rc}"
                } else {
                    echo "ECS update-service triggered successfully"
                    
                    // Optional: Wait for deployment to complete
                    echo "Waiting for deployment to stabilize..."
                    def waitRc = bat(script: "aws ecs wait services-stable --cluster job-portal-production-cluster --services job-portal-production-service --region ${env.AWS_DEFAULT_REGION}", returnStatus: true)
                    
                    if (waitRc == 0) {
                        echo "‚úÖ Production deployment completed successfully"
                    } else {
                        echo "Warning: Deployment may still be in progress (wait command timed out or failed)"
                    }
                }
            }
        }
    }
}
    }
    post {
        success { echo "PIPELINE SUCCESS" }
        failure { echo "PIPELINE FAILED" }
        always { echo "Finished: ${currentBuild.fullDisplayName}" }
    }
}